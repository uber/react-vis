// Extracted from ocular/src/gatsby-node/on-create-node with few changes
const path = require('path');
const _ = require('lodash');
const ocularOptions = require('../ocular-config');

// TODO - avoid globals
const docNodes = {};
let tocNode = null;

function onCreateNode({node, actions, getNode}) {
  // Add missing fields to markdown nodes
  cleanupMarkdownNode({node, actions, getNode}, ocularOptions);

  switch (node.internal.type) {
    case 'Mdx':
      // TODO: This is really nasty.
      // node.fields = {};
      // Note: MarkdownRemark nodes are created by the gatsby-transformer-remark
      // markdown parser. These are different from the original file nodes
      // for the markdown files created by the gatsby-source-filesystem plugin.
      processNewMarkdownNode(
        {node, actions, getNode},
        ocularOptions,
        docNodes,
        tocNode
      );
      break;
    default:
  }
}

// Ensure sourceInstanceName (added by gatsby-source-filsystem config options)
// is present on nodes generated by gatsby-transform-remark
function addSourceInstanceName(
  {node, getNode, loadNodeContent, actions, createNodeId, reporter},
  pluginOptions
) {
  const {createNodeField} = actions;

  const parent = getNode(node.parent);

  const sourceInstanceName =
    parent && parent.sourceInstanceName ? parent.sourceInstanceName : 'unknown';

  // Add node field
  createNodeField({
    node,
    name: 'sourceName',
    value: sourceInstanceName
  });

  // console.error('adding', sourceInstanceName, node.fields.sourceInstanceName)

  // if (!parent) {
  //   // Node has already been processed.
  //   console.error('Ocular markdown node has no parent', JSON.stringify(node.parent), JSON.stringify(node.sourceInstanceName), node.relativePath);
  //   return;
  // }

  if (parent) {
    addMissingFrontmatter(node, sourceInstanceName);
  }
}

function addMissingFrontmatter(node, sourceInstanceName) {
  // Populate frontmatter
  if (node.frontmatter) {
    if (node.rawBody) {
      const title = node.rawBody.split('\n')[0].slice(2);
      node.frontmatter.title = String(title);
      // console.warn(`Ocular processing doc article '${title}'`);
    }
    node.frontmatter.tags = ['default'];
    node.frontmatter.category = 'docs';
    node.frontmatter.cover = 'cover';
    node.frontmatter.type = sourceInstanceName;
  }
}

function cleanupMarkdownNode(
  {node, getNode, loadNodeContent, actions, createNodeId, reporter},
  pluginOptions
) {
  let processed = false;

  if (!processed) {
    switch (node.internal.mediaType) {
      case `text/mdx`:
        addSourceInstanceName(...arguments);
        processed = true;
        break;

      default:
    }
  }

  // Secondary nodes created by remark
  if (!processed) {
    switch (node.internal.type) {
      case 'Mdx':
        addSourceInstanceName(...arguments);
        processed = true;
        break;

      default:
    }
  }

  // if (!processed) {
  //   if (node.internal.mediaType ==- 'application/json') {
  //   }
  //   if (node.id === 'table-of-contents') {
  //   }
  //   console.warn('Ocular ignoring node',
  //     node.absolutePath, node.internal.mediaType, node.internal.type, node.sourceInstanceName);
  // }
};


// From 'gatsby-theme-ocular/src/gatsby-node/on-create-node/process-nodes-markdown'
// Patches up new markdown nodes
//
function processNewMarkdownNode(
  {node, actions, getNode},
  ocularOptions,
  docNodes,
  tocNode
) {
  const {createNodeField} = actions;

  const fileNode = getNode(node.parent);
  const parsedFilePath = path.parse(fileNode.relativePath);
  const hasTitle =
    Object.prototype.hasOwnProperty.call(node, 'frontmatter') &&
    Object.prototype.hasOwnProperty.call(node.frontmatter, 'title');

  let slug;
  if (hasTitle) {
    slug = `/${_.kebabCase(node.frontmatter.title)}`;
  } else if (parsedFilePath.name !== 'index' && parsedFilePath.dir !== '') {
    slug = `/${parsedFilePath.dir}/${parsedFilePath.name}/`;
  } else if (parsedFilePath.dir === '') {
    slug = `/${parsedFilePath.name}/`;
  } else {
    slug = `/${parsedFilePath.dir}/`;
  }
  // Update path
  let relPath = node.fields.slug;
  if (node.fileAbsolutePath) {

    if (ocularOptions.DOC_FOLDER) {
      const src = path.resolve(ocularOptions.DOC_FOLDER);
      const pathBeforeDir = src.substr(0, src.lastIndexOf('/') + 1);
      relPath = node.fileAbsolutePath.replace(pathBeforeDir, '');
    } else if (ocularOptions.DOC_FOLDERS) {
      const index = ocularOptions.DOC_FOLDERS.findIndex(
        folder => node.fileAbsolutePath.includes(path.resolve(folder))
      );
      if (index !== -1) {
        const src = path.resolve(ocularOptions.DOC_FOLDERS[index]);
        const pathBeforeDir = src.substr(0, src.lastIndexOf('/') + 1);
        relPath = node.fileAbsolutePath.replace(pathBeforeDir, '');
      }
    }

    const basename = path.basename(relPath, path.extname(relPath));
    const dirname = path.dirname(relPath);
    relPath = basename === 'README' ? dirname : `${dirname}/${basename}`;

    createNodeField({node, name: 'path', value: relPath});
    createNodeField({node, name: 'slug', value: relPath});
    node.frontmatter.path = relPath;
  }
  if (tocNode) {
    // this means toc node has been created. Any markdown file processed beyond this point wouldn't have its info
    // in the toc.
    // but we can inject it afterwards

    // the regular toc node generation process adds the full content of each markdown node to the toc.
    // we don't need as much. The app will only use the title and slug of the corresponding markdown
    // node for each toc entry.

    const nodeToEdit = parseToc([tocNode], relPath);
    if (nodeToEdit) {
      nodeToEdit.childMarkdownRemark = {
        fields: {
          slug: relPath
        },
        frontmatter: {
          title: node.frontmatter.title
        }
      };
    }
    // log.log({priority: 4, color: COLOR.YELLOW}, `putting ${relPath} back in the TOC`)();
  } else {
    // while toc node isn't created, we can add the docs nodes to docNodes, which is used to add data to the TOC
    // once the toc node is created, there is no reason to keep doing that
    docNodes[relPath] = node;
  }
};

function parseToc(queue, entry) {
  // this function returns a node in the TOC that has an entry corresponding to
  // the path of the current markdown node
  while (queue.length) {
    const n = queue.shift();
    if (n.entry === entry) {
      return n;
    }
    (n.chapters || []).forEach(c => queue.push(c));
    (n.entries || []).forEach(e => queue.push(e));
  }
  // entry not found
  return null;
}

module.exports = onCreateNode;
